<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Annotations - Popup Nav & Reposition</title>
    <!-- ControlKit CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/automat/controlkit.js@master/bin/controlKit.min.css">
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #1a1a1a; color: #fff; }
        .controlKit { z-index: 1000 !important; }
        #info {
            position: absolute; top: 10px; width: 100%; text-align: center;
            z-index: 1; pointer-events: none; color: #ccc; font-size: 0.9em;
        }
        #three-canvas { display: block; width: 100vw; height: 100vh; cursor: default; }
        /* --- Annotation Popup Styles --- */
        #annotation-popup {
            /* display: none; */ /* Start hidden via JS instead */
            visibility: hidden; /* Use visibility for smoother transitions if needed */
            opacity: 0;         /* Start fully transparent */
            position: absolute; background-color: rgba(40, 40, 40, 0.9);
            border: 1px solid #666; border-radius: 5px; padding: 10px 15px; padding-bottom: 35px;
            color: #eee; max-width: 250px; min-width: 180px; z-index: 1001;
            pointer-events: auto; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            font-size: 0.9em; line-height: 1.4; -webkit-user-select: none;
            -ms-user-select: none; user-select: none;
            transition: opacity 0.2s ease-in-out; /* Smooth fade in */
            transform: translate(-50%, -50%); /* Initial center for calculation? Or just set left/top later */
        }
        #annotation-popup.visible {
            visibility: visible;
            opacity: 1;
        }
        #annotation-popup h4 { margin: 0 0 8px 0; padding-bottom: 5px; border-bottom: 1px solid #555; font-size: 1.1em; color: #00aaff; }
        #annotation-popup p { margin: 0; white-space: pre-wrap; word-wrap: break-word; }
        #popup-close { position: absolute; top: 5px; right: 5px; background: rgba(80, 80, 80, 0.8); color: #fff; border: none; border-radius: 50%; width: 20px; height: 20px; line-height: 18px; text-align: center; font-weight: bold; cursor: pointer; font-size: 14px; padding: 0; z-index: 2; }
        #popup-close:hover { background: rgba(120, 0, 0, 0.9); }
        .popup-nav { position: absolute; bottom: 8px; left: 15px; right: 15px; display: flex; justify-content: space-between; }
        .popup-nav button { background: rgba(80, 80, 80, 0.8); color: #fff; border: 1px solid #aaa; border-radius: 3px; padding: 2px 10px; cursor: pointer; font-size: 1.1em; }
        .popup-nav button:hover:not(:disabled) { background: rgba(100, 100, 100, 0.9); }
        .popup-nav button:disabled { opacity: 0.4; cursor: not-allowed; }
    </style>
</head>
<body>
    <div id="info">Nhấp đúp để tạo Annotation | Nhấp STT để xem chi tiết & di chuyển camera</div>

    <canvas id="three-canvas"></canvas>

    <!-- Annotation Popup HTML -->
    <div id="annotation-popup">
        <button id="popup-close">X</button>
        <h4 id="popup-name">Annotation Name</h4>
        <p id="popup-note">Annotation details will appear here.</p>
        <div class="popup-nav">
            <button id="popup-prev">< Trước</button>
            <button id="popup-next">Sau ></button>
        </div>
    </div>

    <!-- Hidden file inputs -->
    <input type="file" id="modelFileInput" accept=".gltf,.glb,.obj" style="display: none;">
    <input type="file" id="hdriFileInput" accept=".hdr,.exr" style="display: none;">

    <!-- Dependencies via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/automat/controlkit.js@master/bin/controlKit.min.js"></script>

    <script>
        // --- Globals ---
        let scene, camera, renderer, controls, currentModel, currentEnvMap;
        const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
        let annotations = []; const annotationSprites = []; let annotationCounter = 1;
        const ANNOTATION_LAYER = 1;
        let controlKit, mainPanel;
        let popupElement, popupNameElement, popupNoteElement, popupCloseButton, popupPrevButton, popupNextButton;
        let currentPopupAnnotationId = null; // ID của annotation đang hiển thị popup
        const SPRITE_SCREEN_SIZE = 0.07; // Kích thước sprite (để tính offset popup)

        const controlSettings = {
            modelFileName: 'Chưa chọn file', hdriFileName: 'Chưa chọn file', exposure: 1.0,
            annotationsVisible: true, // Trạng thái ẩn/hiện
            selectModel: () => document.getElementById('modelFileInput').click(),
            selectHDRI: () => document.getElementById('hdriFileInput').click(),
        };

        // --- Initialization ---
        initThree(); initControlKit(); initPopup(); addEventListeners();

        // --- Three.js Setup ---
        function initThree() { /* ... (Giữ nguyên) ... */
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x1a1a1a); const canvas = document.getElementById('three-canvas'); camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000); camera.position.set(0, 1, 5); camera.layers.enable(0); camera.layers.enable(ANNOTATION_LAYER); renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = controlSettings.exposure; renderer.outputEncoding = THREE.sRGBEncoding; controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.target.set(0, 1, 0); controls.update(); const ambientLight = new THREE.AmbientLight(0xffffff, 0.3); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(5, 10, 7.5); scene.add(directionalLight); animate();
        }
        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); hideAnnotationPopup(); }

        // --- ControlKit Setup ---
        function initControlKit() {
            controlKit = new ControlKit();
            mainPanel = controlKit.addPanel({ label: 'Bảng Điều Khiển', width: 300, align: 'right', fixed: false, opacity: 0.95, position: [15, 15] });
            mainPanel.addGroup({ label: 'Tải File' }) .addStringInput(controlSettings, 'modelFileName', { label: 'Model:', readonly: true }) .addButton('Chọn Model (.gltf, .glb, .obj)', controlSettings.selectModel) .addStringInput(controlSettings, 'hdriFileName', { label: 'HDRI:', readonly: true }) .addButton('Chọn HDRI (.hdr)', controlSettings.selectHDRI);
            mainPanel.addGroup({ label: 'Môi trường' }) .addNumberInput(controlSettings, 'exposure', { label: 'Exposure', step: 0.1, min: 0, max: 3, onChange: (value) => { renderer.toneMappingExposure = value; } });
            mainPanel.addGroup({ label: 'Annotations' })
                .addCheckbox(controlSettings, 'annotationsVisible', {
                    label: 'Hiện Annotations',
                    onChange: toggleAnnotationsVisibility // <<< Gọi hàm này khi checkbox thay đổi
                });
        }

        // --- Popup Setup ---
        function initPopup() { /* ... (Giữ nguyên) ... */
            popupElement = document.getElementById('annotation-popup'); popupNameElement = document.getElementById('popup-name'); popupNoteElement = document.getElementById('popup-note'); popupCloseButton = document.getElementById('popup-close'); popupPrevButton = document.getElementById('popup-prev'); popupNextButton = document.getElementById('popup-next'); if (!popupElement || !popupNameElement || !popupNoteElement || !popupCloseButton || !popupPrevButton || !popupNextButton) { console.error("Không tìm thấy các thành phần HTML của Popup!"); return; } popupCloseButton.addEventListener('click', hideAnnotationPopup); popupPrevButton.addEventListener('click', navigateToPreviousAnnotation); popupNextButton.addEventListener('click', navigateToNextAnnotation);
        }

        // --- Event Listeners ---
        function addEventListeners() { /* ... (Giữ nguyên) ... */
             window.addEventListener('resize', onWindowResize); renderer.domElement.addEventListener('dblclick', onDoubleClick); renderer.domElement.addEventListener('click', onSingleClick); document.getElementById('modelFileInput').addEventListener('change', handleModelFileSelect); document.getElementById('hdriFileInput').addEventListener('change', handleHDRIFileSelect);
        }

        // --- File Handling ---
        function handleModelFileSelect(event) { const file = event.target.files[0]; if (file) { loadModel(file); } event.target.value = null; }
        function handleHDRIFileSelect(event) { const file = event.target.files[0]; if (file) { loadHDRI(file); } event.target.value = null; }

        // --- Canvas Click/Double Click ---
        function onDoubleClick(event) { /* ... (Giữ nguyên - Create annotation, save view) ... */
             if (!currentModel) { alert("Vui lòng tải model trước."); return; } updateMouseCoords(event); raycaster.setFromCamera(mouse, camera); raycaster.layers.set(0); const intersects = raycaster.intersectObject(currentModel, true); if (intersects.length > 0) { const intersectionPoint = intersects[0].point; const annotationName = prompt(`Annotation ${annotationCounter} - Nhập Tên:`, `Annotation ${annotationCounter}`); if (annotationName === null) return; if (annotationName.trim() === "") { alert("Tên không được để trống."); return; } const annotationNote = prompt(`Annotation ${annotationCounter} (${annotationName}) - Nhập Nội dung:`, `Chi tiết...`); if (annotationNote === null) return; createAnnotation(intersectionPoint, annotationName.trim(), annotationNote); }
        }

        function onSingleClick(event) { // Show Popup AND Move Camera
            if (annotationSprites.length === 0) return;
            updateMouseCoords(event); raycaster.setFromCamera(mouse, camera); raycaster.layers.set(ANNOTATION_LAYER);
            const intersects = raycaster.intersectObjects(annotationSprites.filter(s => s.visible), false); // Chỉ kiểm tra sprite đang hiển thị

            if (intersects.length > 0) {
                const clickedSprite = intersects[0].object; const annotationId = clickedSprite.userData.annotationId;
                const annotation = annotations.find(a => a.id === annotationId);
                if (annotation) {
                    console.log(`[Sprite Click] Annotation ${annotation.id}.`);
                    // 1. Cập nhật nội dung popup & ID hiện tại (nhưng chưa hiện ngay)
                    updatePopupContent(annotation);
                    // 2. Di chuyển camera (popup sẽ được định vị lại khi animation xong)
                    animateCameraToView(annotation.cameraPosition, annotation.cameraTarget);
                }
            } else {
                 hideAnnotationPopup(); // Clicked outside visible sprites
            }
        }

        function updateMouseCoords(event) { /* ... (Giữ nguyên) ... */
            const rect = renderer.domElement.getBoundingClientRect(); mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
         }

        // --- Annotation Logic ---
        function createAnnotation(position, name, note) {
             console.log("Đang lưu annotation và góc nhìn camera hiện tại..."); const annotationData = { id: annotationCounter, name: name, note: note, position: position.clone(), cameraPosition: camera.position.clone(), cameraTarget: controls.target.clone() }; annotations.push(annotationData); const sprite = createAnnotationSprite(annotationData);
             sprite.visible = controlSettings.annotationsVisible; // <<< Đặt visibility ban đầu
             scene.add(sprite); annotationSprites.push(sprite); annotationCounter++; updateAnnotationListControlKit(); console.log("Annotation và view đã lưu:", annotationData);
         }
        function createAnnotationSprite(annotationData) { /* ... (Giữ nguyên) ... */
            const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const size = 64; canvas.width = size; canvas.height = size; const number = annotationData.id.toString(); const radius = size / 2 - 4; context.fillStyle = 'rgba(0, 100, 220, 0.75)'; context.beginPath(); context.arc(size / 2, size / 2, radius, 0, Math.PI * 2); context.fill(); context.strokeStyle = 'rgba(255, 255, 255, 0.8)'; context.lineWidth = 2; context.stroke(); context.fillStyle = 'white'; context.font = `bold ${size / 2.8}px Arial`; context.textAlign = 'center'; context.textBaseline = 'middle'; context.fillText(number, size / 2, size / 2 + 1); const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; const spriteMaterial = new THREE.SpriteMaterial({ map: texture, sizeAttenuation: false, depthTest: false, transparent: true, opacity: 0.85 }); const sprite = new THREE.Sprite(spriteMaterial); sprite.position.copy(annotationData.position); sprite.scale.set(SPRITE_SCREEN_SIZE, SPRITE_SCREEN_SIZE, SPRITE_SCREEN_SIZE); sprite.layers.set(ANNOTATION_LAYER); sprite.userData.annotationId = annotationData.id; sprite.userData.isAnnotation = true; return sprite;
        }

        // --- ControlKit Update ---
        function updateAnnotationListControlKit() { // Không còn list nhưng vẫn update phòng khi có control khác
             if (!controlKit) return; controlKit.update();
         }

        // --- Toggle Annotation Visibility ---
        // *** SỬA LỖI: Đọc giá trị từ controlSettings ***
        function toggleAnnotationsVisibility() {
            const isVisible = controlSettings.annotationsVisible; // <<< Đọc giá trị hiện tại từ settings
            console.log(`Setting annotation visibility to: ${isVisible}`);
            annotationSprites.forEach(sprite => {
                sprite.visible = isVisible;
            });
            if (!isVisible) {
                hideAnnotationPopup(); // Ẩn popup nếu tắt annotations
            }
        }

        function clearAnnotations() { /* ... (Giữ nguyên) ... */
            hideAnnotationPopup(); currentPopupAnnotationId = null; annotationSprites.forEach(sprite => { if (sprite.material.map) sprite.material.map.dispose(); sprite.material.dispose(); scene.remove(sprite); }); annotationSprites.length = 0; annotations = []; annotationCounter = 1; updateAnnotationListControlKit(); console.log("Tất cả annotations đã được xóa.");
        }

        // --- Popup Logic ---
        // Hàm chỉ cập nhật nội dung và ID, không hiển thị/định vị
        function updatePopupContent(annotationData) {
            if (!popupElement || !annotationData) return;
            popupNameElement.textContent = annotationData.name;
            popupNoteElement.textContent = annotationData.note;
            currentPopupAnnotationId = annotationData.id;
            updatePopupNavButtons();
        }

        // Hàm định vị lại popup, thường gọi sau khi camera di chuyển xong
        function repositionCurrentPopup() {
            if (!popupElement || currentPopupAnnotationId === null) return;
            const annotation = annotations.find(a => a.id === currentPopupAnnotationId);
            if (!annotation) { hideAnnotationPopup(); return; }

            const position3D = annotation.position.clone();
            const vector = position3D.project(camera); // Tính toán với camera MỚI

            if (vector.z > 1) { hideAnnotationPopup(); return; } // Vẫn ẩn nếu điểm bị che

            const screenX = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const screenY = (-vector.y * 0.5 + 0.5) * renderer.domElement.clientHeight;

            // Tính toán vị trí "bên cạnh" sprite
            const popupWidth = popupElement.offsetWidth;
            const popupHeight = popupElement.offsetHeight;
            const spritePixelRadius = (SPRITE_SCREEN_SIZE * renderer.domElement.clientHeight) / 2; // Ước lượng bán kính sprite trên màn hình
            const gap = 10; // Khoảng cách giữa sprite và popup

            let finalLeft = screenX + spritePixelRadius + gap;
            let finalTop = screenY - popupHeight / 2; // Căn giữa theo chiều dọc

            // Kiểm tra biên màn hình
            if (finalLeft + popupWidth > window.innerWidth - 10) { // Nếu tràn sang phải
                finalLeft = screenX - spritePixelRadius - gap - popupWidth; // Đặt sang trái
            }
            if (finalTop < 10) { // Nếu tràn lên trên
                finalTop = 10;
            } else if (finalTop + popupHeight > window.innerHeight - 10) { // Nếu tràn xuống dưới
                finalTop = window.innerHeight - 10 - popupHeight;
            }

            // Áp dụng vị trí và hiển thị (dùng class 'visible' để có transition)
            popupElement.style.left = `${Math.round(finalLeft)}px`;
            popupElement.style.top = `${Math.round(finalTop)}px`;
            popupElement.classList.add('visible'); // Thêm class để kích hoạt transition và visibility

            console.log(`Repositioned popup for annotation ${annotation.id}`);
        }


        function hideAnnotationPopup() {
            if (popupElement) {
                // popupElement.style.display = 'none';
                popupElement.classList.remove('visible'); // Xóa class để ẩn và kích hoạt transition out
            }
            currentPopupAnnotationId = null;
        }

        function updatePopupNavButtons() { /* ... (Giữ nguyên) ... */
            if (!popupPrevButton || !popupNextButton || currentPopupAnnotationId === null || annotations.length <= 1) { if(popupPrevButton) popupPrevButton.disabled = true; if(popupNextButton) popupNextButton.disabled = true; return; } const sortedAnnotations = [...annotations].sort((a, b) => a.id - b.id); const currentIndex = sortedAnnotations.findIndex(a => a.id === currentPopupAnnotationId); popupPrevButton.disabled = (currentIndex <= 0); popupNextButton.disabled = (currentIndex >= sortedAnnotations.length - 1);
        }

        // --- Popup Navigation ---
        function navigateToPreviousAnnotation() {
             if (popupPrevButton.disabled || currentPopupAnnotationId === null) return;
             const sortedAnnotations = [...annotations].sort((a, b) => a.id - b.id);
             const currentIndex = sortedAnnotations.findIndex(a => a.id === currentPopupAnnotationId);
             if (currentIndex > 0) {
                 const prevAnnotation = sortedAnnotations[currentIndex - 1];
                 console.log(`Navigating to previous: ${prevAnnotation.id}`);
                 // 1. Cập nhật nội dung popup (chưa hiện)
                 updatePopupContent(prevAnnotation);
                 // 2. Di chuyển camera (sẽ gọi reposition khi xong)
                 animateCameraToView(prevAnnotation.cameraPosition, prevAnnotation.cameraTarget);
             }
        }

        function navigateToNextAnnotation() {
             if (popupNextButton.disabled || currentPopupAnnotationId === null) return;
             const sortedAnnotations = [...annotations].sort((a, b) => a.id - b.id);
             const currentIndex = sortedAnnotations.findIndex(a => a.id === currentPopupAnnotationId);
             if (currentIndex < sortedAnnotations.length - 1) {
                 const nextAnnotation = sortedAnnotations[currentIndex + 1];
                 console.log(`Navigating to next: ${nextAnnotation.id}`);
                 // 1. Cập nhật nội dung popup (chưa hiện)
                 updatePopupContent(nextAnnotation);
                 // 2. Di chuyển camera (sẽ gọi reposition khi xong)
                 animateCameraToView(nextAnnotation.cameraPosition, nextAnnotation.cameraTarget);
             }
        }

        // --- Camera Animation ---
        function animateCameraToView(targetPosition, targetTarget, duration = 1.2) {
            if (gsap.isTweening(camera.position) || gsap.isTweening(controls.target)) { console.log("Animation đang chạy, bỏ qua yêu cầu mới."); return; }
            controls.enabled = false;
            gsap.to(camera.position, { duration: duration, x: targetPosition.x, y: targetPosition.y, z: targetPosition.z, ease: "power3.inOut",
                onComplete: () => {
                     // <<< GỌI REPOSITION KHI CAMERA ĐẾN NƠI >>>
                     repositionCurrentPopup();
                }
            });
            gsap.to(controls.target, { duration: duration, x: targetTarget.x, y: targetTarget.y, z: targetTarget.z, ease: "power3.inOut",
                onUpdate: () => controls.update(),
                onComplete: () => { controls.enabled = true; controls.update(); console.log("Animation camera hoàn tất."); }
            });
        }

        // --- Loading Functions ---
        function loadModel(file) { /* ... (Giữ nguyên) ... */
             clearAnnotations(); if (currentModel) { scene.remove(currentModel); currentModel = null; console.log("Đã xóa model cũ."); } controlSettings.modelFileName = `Đang xử lý: ${file.name}...`; controlKit.update(); console.log(`Bắt đầu tải model: ${file.name}`); const filename = file.name.toLowerCase(); const reader = new FileReader(); let loader; try { if (filename.endsWith('.gltf') || filename.endsWith('.glb')) loader = new THREE.GLTFLoader(); else if (filename.endsWith('.obj')) loader = new THREE.OBJLoader(); else throw new Error(`Định dạng file model không được hỗ trợ: .${filename.split('.').pop()}`); } catch (error) { console.error("Lỗi chọn loader:", error); alert(`Lỗi: ${error.message}`); controlSettings.modelFileName = 'Lỗi định dạng file'; controlKit.update(); return; } reader.onload = (e) => { const contents = e.target.result; console.log(`File "${file.name}" đã đọc xong, bắt đầu parse...`); controlSettings.modelFileName = `Đang parse: ${file.name}...`; controlKit.update(); let parsePromise; try { if (loader instanceof THREE.GLTFLoader) parsePromise = new Promise((resolve, reject) => loader.parse(contents, '', resolve, reject)); else if (loader instanceof THREE.OBJLoader) parsePromise = new Promise((resolve) => resolve(loader.parse(contents))); } catch (parseError) { console.error(`Lỗi ngay khi gọi parse cho "${file.name}":`, parseError); alert(`Lỗi nghiêm trọng khi parse model "${file.name}". Xem console.`); controlSettings.modelFileName = 'Lỗi parse file'; controlKit.update(); return; } parsePromise.then((result) => { console.log(`Parse thành công "${file.name}", đang xử lý kết quả...`); controlSettings.modelFileName = `Đang xử lý: ${file.name}...`; controlKit.update(); if (!result) throw new Error("Kết quả parse không hợp lệ (null hoặc undefined)."); const modelToAdd = result.scene ? result.scene : result; if (!modelToAdd || !(modelToAdd instanceof THREE.Object3D)) throw new Error("Đối tượng model chính từ kết quả parse không hợp lệ."); try { modelToAdd.traverse(child => { if (child.isMesh) { child.layers.set(0); if (loader instanceof THREE.OBJLoader) { if (!child.material || child.material.type === 'MeshBasicMaterial') { child.material = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.5, roughness: 0.5, envMap: currentEnvMap, envMapIntensity: currentEnvMap ? 1.0 : 0 }); } } else if (child.material && currentEnvMap && (child.material.isMeshStandardMaterial || child.material.isMeshPhysicalMaterial)) { child.material.envMap = currentEnvMap; child.material.envMapIntensity = 1.0; child.material.needsUpdate = true; } } }); scene.add(modelToAdd); currentModel = modelToAdd; console.log(`Model "${file.name}" đã được thêm vào scene.`); const fitSuccess = fitCameraToObject(currentModel, 1.5); if (!fitSuccess) console.warn(`Có vấn đề khi điều chỉnh camera cho model "${file.name}".`); controlSettings.modelFileName = file.name; alert(`Model "${file.name}" đã được tải thành công!`); console.log("Model loaded successfully!"); } catch (processingError) { console.error(`Lỗi trong quá trình xử lý sau parse cho "${file.name}":`, processingError); if (currentModel) scene.remove(currentModel); currentModel = null; throw new Error(`Lỗi xử lý model sau khi parse: ${processingError.message}`); } }).catch((error) => { console.error(`Lỗi trong quá trình parse hoặc xử lý model "${file.name}":`, error); alert(`Lỗi khi tải model "${file.name}". ${error.message || 'Xem console để biết chi tiết.'}`); controlSettings.modelFileName = 'Lỗi tải/xử lý file'; if (currentModel) scene.remove(currentModel); currentModel = null; }).finally(() => { controlKit.update(); console.log(`Hoàn tất xử lý cho "${file.name}".`); }); }; reader.onerror = (e) => { console.error("Lỗi đọc file bằng FileReader:", file.name, e); alert("Không thể đọc file model: " + file.name); controlSettings.modelFileName = 'Lỗi đọc file'; controlKit.update(); }; if (loader instanceof THREE.GLTFLoader) reader.readAsArrayBuffer(file); else if (loader instanceof THREE.OBJLoader) reader.readAsText(file);
        }

        function loadHDRI(file) { /* ... (Giữ nguyên) ... */
            console.log("Bắt đầu tải HDRI:", file.name); controlSettings.hdriFileName = "Đang tải..."; controlKit.update(); if (!file.name.toLowerCase().endsWith('.hdr')) { alert("Hiện tại chỉ hỗ trợ định dạng .hdr cho HDRI."); controlSettings.hdriFileName = 'Chỉ hỗ trợ .hdr'; controlKit.update(); return; } const reader = new FileReader(); reader.onload = (e) => { const dataUrl = e.target.result; const loader = new THREE.RGBELoader(); try { const onLoad = (texture) => { texture.mapping = THREE.EquirectangularReflectionMapping; if (currentEnvMap) currentEnvMap.dispose(); scene.background = texture; scene.environment = texture; currentEnvMap = texture; if(currentModel) { currentModel.traverse(child => { if (child.isMesh && (child.material.isMeshStandardMaterial || child.material.isMeshPhysicalMaterial)) { child.material.envMap = currentEnvMap; child.material.envMapIntensity = 1.0; child.material.needsUpdate = true; } }); console.log("Đã áp dụng HDRI mới cho model hiện tại."); } controlSettings.hdriFileName = file.name; alert(`HDRI "${file.name}" đã được tải và áp dụng!`); console.log("HDRI loaded successfully!"); controlKit.update(); }; const onError = (error) => { console.error(/*...*/); alert(/*...*/); controlSettings.hdriFileName = 'Lỗi tải file'; controlKit.update(); }; loader.load(dataUrl, onLoad, undefined, onError); } catch(error) { console.error(/*...*/); alert(/*...*/); controlSettings.hdriFileName = 'Lỗi loader'; controlKit.update(); } }; reader.onerror = (e) => { console.error(/*...*/); alert(/*...*/); controlSettings.hdriFileName = 'Lỗi đọc file'; controlKit.update(); }; reader.readAsDataURL(file);
        }

        // --- Utility: Fit Camera (returns true/false) ---
        function fitCameraToObject(object, offset = 1.3) { /* ... (Giữ nguyên) ... */
             const box = new THREE.Box3().setFromObject(object); const isBoxValid = !box.isEmpty() && Number.isFinite(box.min.x) && Number.isFinite(box.min.y) && Number.isFinite(box.min.z) && Number.isFinite(box.max.x) && Number.isFinite(box.max.y) && Number.isFinite(box.max.z); if (!isBoxValid) { console.warn("Bounding Box không hợp lệ/rỗng. Không thể tự động điều chỉnh camera."); return false; } const size = box.getSize(new THREE.Vector3()); const center = box.getCenter(new THREE.Vector3()); const maxSize = Math.max(size.x, size.y, size.z); if (maxSize < Number.EPSILON) { console.warn("Kích thước model rất nhỏ/bằng 0. Đặt camera gần tâm."); camera.position.set(center.x, center.y, center.z + 1); controls.target.copy(center); controls.minDistance = 0.01; controls.maxDistance = 10; controls.update(); return false; } const fitHeightDistance = maxSize / (2 * Math.atan(Math.PI * camera.fov / 360)); const fitWidthDistance = fitHeightDistance / camera.aspect; const distance = offset * Math.max(fitHeightDistance, fitWidthDistance); const direction = controls.target.clone().sub(camera.position).normalize().multiplyScalar(distance); controls.maxDistance = distance * 20; controls.minDistance = Math.max(0.01, distance / 20); controls.target.copy(center); camera.near = Math.max(0.001, distance / 1000); camera.far = distance * 100; camera.updateProjectionMatrix(); camera.position.copy(controls.target).sub(direction); controls.update(); console.log("Camera đã được điều chỉnh thành công."); return true;
        }

    </script>
</body>
</html>