
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Viewer with Full Annotation Logic</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #000; }
    canvas { width: 100vw; height: 100vh; display: block; }
    #annotation-popup {
      position: absolute; background: rgba(40, 40, 40, 0.9); color: #fff;
      border-radius: 5px; padding: 10px; display: none; max-width: 250px;
      font-family: sans-serif; font-size: 0.9em;
    }
  </style>
</head>
<body>
  <canvas id="three-canvas"></canvas>
  <div id="annotation-popup">
    <h4 id="popup-title"></h4>
    <p id="popup-text"></p>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
    import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/RGBELoader.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import gsap from 'https://cdn.jsdelivr.net/npm/gsap@3.11.5/index.js';

    const embeddedJSONString = "{\"modelFileName\": \"sample.glb\", \"modelDataUrl\": \"data:application/octet-stream;base64,SampleModelData==\", \"hdriDataUrl\": \"data:application/octet-stream;base64,SampleHDRIData==\", \"exposure\": 1.0, \"timeline\": {\"hasAnimation\": true, \"longestDuration\": 5, \"initialTime\": 0}, \"annotations\": [{\"id\": 1, \"name\": \"Annotation 1\", \"note\": \"This is the first annotation.\", \"position\": {\"x\": 0, \"y\": 1, \"z\": 2}, \"animationTime\": 1.2, \"cameraPosition\": {\"x\": 2, \"y\": 2, \"z\": 5}, \"cameraTarget\": {\"x\": 0, \"y\": 1, \"z\": 0}}, {\"id\": 2, \"name\": \"Annotation 2\", \"note\": \"Second point of interest.\", \"position\": {\"x\": 1, \"y\": 0.5, \"z\": -1}, \"animationTime\": 3.7, \"cameraPosition\": {\"x\": -2, \"y\": 2, \"z\": 3}, \"cameraTarget\": {\"x\": 1, \"y\": 0.5, \"z\": -1}}]}";
    const data = JSON.parse(JSON.parse(embeddedJSONString));

    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMappingExposure = data.exposure || 1;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1, 5);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1, 0);
    controls.update();

    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    if (data.hdriDataUrl) {
      new RGBELoader().load(data.hdriDataUrl, texture => {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.environment = texture;
      });
    }

    let mixer = null, clock = new THREE.Clock(), sprites = [];

    new GLTFLoader().load(data.modelDataUrl, gltf => {
      scene.add(gltf.scene);
      if (gltf.animations.length > 0) {
        mixer = new THREE.AnimationMixer(gltf.scene);
        gltf.animations.forEach(clip => mixer.clipAction(clip).play());
      }
      data.annotations.forEach(a => {
        const sprite = createAnnotationSprite(a);
        sprite.position.set(a.position.x, a.position.y, a.position.z);
        sprite.userData.annotation = a;
        scene.add(sprite);
        sprites.push(sprite);
      });
    });

    function createAnnotationSprite(a) {
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,255,0.8)';
      ctx.beginPath(); ctx.arc(32, 32, 28, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.font = '20px sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(a.id, 32, 34);
      const texture = new THREE.CanvasTexture(canvas);
      return new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
    }

    renderer.domElement.addEventListener('click', e => {
      const rect = renderer.domElement.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(sprites);
      if (hits.length > 0) {
        const ann = hits[0].object.userData.annotation;
        showPopup(ann);
        if (ann.cameraPosition && ann.cameraTarget) {
          animateCameraToView(ann.cameraPosition, ann.cameraTarget);
        }
        if (ann.animationTime && mixer) {
          mixer.setTime(ann.animationTime);
        }
      }
    });

    const popup = document.getElementById('annotation-popup');
    const popupTitle = document.getElementById('popup-title');
    const popupText = document.getElementById('popup-text');

    function showPopup(ann) {
      popupTitle.textContent = ann.name;
      popupText.textContent = ann.note;
      popup.style.display = 'block';
    }

    function animateCameraToView(pos, target) {
      const to = new THREE.Vector3(pos.x, pos.y, pos.z);
      const look = new THREE.Vector3(target.x, target.y, target.z);
      gsap.to(camera.position, {
        duration: 1, x: to.x, y: to.y, z: to.z,
        onUpdate: () => camera.updateProjectionMatrix()
      });
      gsap.to(controls.target, {
        duration: 1, x: look.x, y: look.y, z: look.z,
        onUpdate: () => controls.update()
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      if (mixer) mixer.update(clock.getDelta());
      controls.update();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
