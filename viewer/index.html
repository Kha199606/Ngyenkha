<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Three.js - Timeline Sync</title>
	<link rel="stylesheet" href="main.css"> <!-- Assuming main.css exists -->
    <link rel="stylesheet" href="css/sidebar.css">

    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; }
    </style>
    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ion-rangeslider/2.3.1/css/ion.rangeSlider.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ion-rangeslider/2.3.1/js/ion.rangeSlider.min.js"></script>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"

            }
        }
    </script>
</head>
<body>
    <div id="container"></div>
    <div id="timeline" style="display:none;">
        <div id="timeline-controls">
            <div id="timeline-range-wrap">
                <div id="timeline-range">
                    <input type="text" id="timeline-range-input" name="timeline_range" value="" />
                </div>
            </div>
            <div id="timeline-progress-wrap">
                <div id="timeline-progress">
                    <input type="text" id="timeline-progress-input" name="timeline_progress" value="" />
                </div>
                <div id="timeline-pause-resume"><div class="play-icon"></div><div class="pause-icon"></div></div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        let scene, camera, renderer, controls, mixer, clock;
        let animationActions = [];
        let longestAction = null;
        let timelineElement = document.getElementById('timeline');
        let pauseResumeButton = document.getElementById('timeline-pause-resume');
        let rangeSliderInstance, progressSliderInstance;
        let isDraggingSlider = false;
        let longestDuration = 0;

        function prettifyNumber(num) { return num.toFixed(0); }

        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            new RGBELoader().load('Hall.hdr', (t) => {
                t.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = t;
                scene.environment = t;
            });

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);

            const loader = new GLTFLoader();
            loader.load('Default_model_v2.glb', (gltf) => {
                const model = gltf.scene;
                scene.add(model);

                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxD = Math.max(size.x, size.y, size.z);
                const camZ = Math.max(maxD * 1.2, Math.abs(maxD / 1.5 / Math.tan(camera.fov * Math.PI / 360)));
                camera.position.set(center.x, center.y + size.y * 0.2, center.z + camZ);
                controls.target.copy(center);
                controls.update();

                if (gltf.animations.length) {
                    mixer = new THREE.AnimationMixer(model);
                    animationActions = gltf.animations.map(clip => {
                        const action = mixer.clipAction(clip);
                        action.weight = 1;
                        return action;
                    });

                    longestAction = animationActions.reduce((a, b) => (a._clip.duration > b._clip.duration ? a : b));
                    longestDuration = longestAction._clip.duration;

                    animationActions.forEach(a => a.play());
                    setupTimelineControls();
                }
            });

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function setupTimelineControls() {
            if (!mixer || !longestAction || animationActions.length === 0) return;

            timelineElement.style.display = 'block';
            pauseResumeButton.onclick = togglePlayPause;
            updatePlayPauseButton();

            $("#timeline-range-input").ionRangeSlider({
                skin: "flat", type: "double", min: 0, max: longestDuration,
                from: 0, to: longestDuration, step: 0.01, grid: true,
                grid_num: 10, prettify: prettifyNumber,
            });
            rangeSliderInstance = $("#timeline-range-input").data("ionRangeSlider");

            $("#timeline-progress-input").ionRangeSlider({
                skin: "flat", type: "single", min: 0, max: longestDuration,
                from: 0, step: 0.01, grid: false, prettify: prettifyNumber,
                hide_min_max: true, hide_from_to: false,
                onStart: () => {
                    isDraggingSlider = true;
                    if (!animationActions[0].paused) {
                        animationActions.forEach(action => action.paused = true);
                        updatePlayPauseButton();
                    }
                },
                onChange: data => {
                    const targetTime = data.from;
                    animationActions.forEach(action => action.time = targetTime);
                    mixer.update(0);
                },
                onFinish: () => {
                    isDraggingSlider = false;
                }
            });
            progressSliderInstance = $("#timeline-progress-input").data("ionRangeSlider");
        }

        function togglePlayPause() {
            if (isDraggingSlider || animationActions.length === 0 || !progressSliderInstance) return;

            const newPaused = !animationActions[0].paused;
            if (!newPaused) {
                const targetTime = progressSliderInstance.result.from;
                animationActions.forEach(action => action.time = targetTime);
                mixer.update(0);
                clock.getDelta();
            }
            animationActions.forEach(action => action.paused = newPaused);
            updatePlayPauseButton();
        }

        function updatePlayPauseButton() {
            if (!pauseResumeButton || animationActions.length === 0) return;
            pauseResumeButton.classList.toggle('paused', animationActions[0].paused);
        }

        function autoIncrementTimeline() {
            if (!progressSliderInstance || !mixer || animationActions.length === 0) return;

            const currentSliderTime = progressSliderInstance.result.from;
            let newTime = (currentSliderTime + 0.01) % longestDuration;
            newTime = Math.max(0, newTime);

            if (Math.abs(currentSliderTime - newTime) > 0.001) {
                progressSliderInstance.update({ from: newTime });
            }

            animationActions.forEach(action => action.time = newTime);
            return newTime;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            controls.update();

            if (animationActions.length > 0 && !animationActions[0].paused) {
                const targetTime = autoIncrementTimeline();
                if (targetTime !== undefined) {
                    animationActions.forEach(action => action.time = targetTime);
                    mixer.update(0);
                }
            }

            if (!isDraggingSlider && animationActions.length > 0 && !animationActions[0].paused && progressSliderInstance) {
                const currentTime = longestAction.time % longestDuration;
                const sliderValue = progressSliderInstance.result.from;
                if (Math.abs(sliderValue - currentTime) > 0.01) {
                    progressSliderInstance.update({ from: currentTime });
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (rangeSliderInstance) rangeSliderInstance.update({});
            if (progressSliderInstance) progressSliderInstance.update({});
        }

        init();
    </script>
    <script type="module"  src="js/sidebar.js"></script>
    <script type="module"  src="js/main.js"></script>
</body>
</html>
